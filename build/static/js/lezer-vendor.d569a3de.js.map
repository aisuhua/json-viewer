{"version":3,"file":"static/js/lezer-vendor.d569a3de.js","mappings":"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","sources":["../node_modules/@lezer/common/dist/index.js","../node_modules/@lezer/highlight/dist/index.js","../node_modules/@lezer/lr/dist/index.js","../node_modules/@lezer/json/dist/index.es.js"],"sourcesContent":["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /// Define a node type.\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method can be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n    /// objects, not nodes packed into\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /// Enable this to make iteration include anonymous nodes (such as\n    /// the nodes that wrap repeated grammar constructs into a balanced\n    /// tree).\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n    /// replace their base node in iteration. Enable this to ignore them\n    /// instead.\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /// This option only applies in\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    /// library to not enter mounted overlays if one covers the given\n    /// position.\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    /// the tree. Mode can be used to [control](#common.IterMode) which\n    /// nodes the cursor visits.\n    cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    /// at the given position and side (see\n    /// [`moveTo`](#common.TreeCursor.moveTo).\n    cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    ///\n    /// Note that this will not enter\n    /// [overlays](#common.MountedTree.overlay), and you often want\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n            let entered = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild())\n                    continue;\n                entered = true;\n            }\n            for (;;) {\n                if (entered && leave && !c.type.isAnonymous)\n                    leave(c);\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                entered = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, mode);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(_tree, from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this._tree.type; }\n    get name() { return this._tree.type.name; }\n    get to() { return this.from + this._tree.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) &&\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return this._tree; }\n    toTree() { return this._tree; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this._tree.toString(); }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for (let p = node.parent; i >= 0; p = p.parent) {\n        if (!p)\n            return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name)\n                return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    get node() { return this; }\n    matchContext(context) { return matchNodeContext(this, context); }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        /// @internal\n        this.buffer = null;\n        this.stack = [];\n        /// @internal\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, mode = this.mode) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n                    let child = parent._tree.children[i];\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\n                        child instanceof TreeBuffer ||\n                        !child.type.isAnonymous ||\n                        hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /// Iterate over the current node and all its descendants, calling\n    /// `enter` when entering a node and `leave`, if given, when leaving\n    /// one. When `enter` returns `false`, any children of that node are\n    /// skipped, and `leave` isn't called for it.\n    iterate(enter, leave) {\n        for (let depth = 0;;) {\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling())\n                    break;\n                if (!depth)\n                    return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Test whether the current node matches a given contexta sequence\n    /// of direct parent node names. Empty strings in the context array\n    /// are treated as wildcards.\n    matchContext(context) {\n        if (!this.buffer)\n            return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n            if (d < 0)\n                return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name)\n                    return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n    constructor() {\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner)\n            this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /// Set the value for this syntax node.\n    set(node, value) {\n        if (node instanceof BufferNode)\n            this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode)\n            this.map.set(node.tree, value);\n    }\n    /// Retrieve value for this syntax node, if it exists in the map.\n    get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /// Set the value for the node that a cursor currently points to.\n    cursorSet(cursor, value) {\n        if (cursor.buffer)\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else\n            this.map.set(cursor.tree, value);\n    }\n    /// Retrieve the value for the node that a cursor currently points\n    /// to.\n    cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment. You'll usually want to use\n    /// [`addTree`](#common.TreeFragment^addTree) and\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    /// calling this directly.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, IterMode, MountedTree, NodeProp, NodeSet, NodeType, NodeWeakMap, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n","import { NodeProp } from '@lezer/common';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of this tag and all its parent tags, starting with\n    /// this one itself and sorted in order of decreasing specificity.\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\n    /// this tag will try to fall back to the parent tag (or grandparent\n    /// tag, etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelwildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Opaque */; }\n    get inherit() { return this.mode == 1 /* Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Normal */, null);\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle, \n/// The start of the range to highlight.\nfrom = 0, \n/// The end of the range.\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(cursor.from, cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(to, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/// Match a syntax node's [highlight rules](#highlight.styleTags). If\n/// there's a match, return its set of tags, and whether it is\n/// opaque (uses a `!`) or applies to all child nodes (`/...`).\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementif your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property or field [name](#highlight.tags.name).\n    propertyName: propertyName,\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    attributeName: t(propertyName),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\n    attributeValue: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) related to defining or\n    /// interfacing with modules.\n    moduleKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that dereferences something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// [Content](#highlight.tags.content) that has a strike-through\n    /// style.\n    strikethrough: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\nexport { Tag, classHighlighter, getStyleTags, highlightTree, styleTags, tagHighlighter, tags };\n","import { Parser, NodeSet, NodeType, DefaultBufferLength, NodeProp, Tree, IterMode } from '@lezer/common';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special casethey add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /// @internal\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// @internal\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsingwhen looking forwardor even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // , , , , , , , , , , , , , \n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// Holds the parse tables for a given grammar, as generated by\n/// `lezer-generator`, and provides [methods](#common.Parser) to parse\n/// content with.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 14 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    /// are registered for this parser.\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// Used by the output of the parser generator. Not available to\n    /// user code.\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Extend */ : 0 /* Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n","import { LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\nconst jsonHighlighting = styleTags({\n  String: tags.string,\n  Number: tags.number,\n  \"True False\": tags.bool,\n  PropertyName: tags.propertyName,\n  Null: tags.null,\n  \",\": tags.separator,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j\",\n  stateData: \"#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O\",\n  goto: \"!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \" JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 25,\n  nodeProps: [\n    [\"openedBy\", 7,\"{\",12,\"[\"],\n    [\"closedBy\", 8,\"}\",13,\"]\"]\n  ],\n  propSources: [jsonHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~\",\n  tokenizers: [0],\n  topRules: {\"JsonText\":[0,1]},\n  tokenPrec: 0\n});\n\nexport { parser };\n"],"names":["DefaultBufferLength","nextPropID","Range","from","to","this","NodeProp","config","id","perNode","deserialize","Error","match","RangeError","NodeType","type","result","undefined","closedBy","str","split","openedBy","group","contextHash","lookAhead","mounted","noProps","Object","create","name","props","flags","prop","indexOf","spec","length","top","skipped","error","src","Array","isArray","map","direct","node","groups","i","found","none","IterMode","NodeSet","types","newTypes","newProps","source","add","assign","push","CachedNode","WeakMap","CachedInnerNode","Tree","children","positions","value","overlay","tree","toString","test","isError","JSON","stringify","mode","TreeCursor","topNode","pos","side","scope","get","cursor","moveTo","set","_tree","TreeNode","resolveNode","enter","leave","c","IncludeAnonymous","entered","isAnonymous","firstChild","nextSibling","parent","balanceRange","propValues","makeTree","data","buildTree","empty","FlatBufferCursor","buffer","index","TreeBuffer","childString","join","endIndex","startIndex","dir","pick","checkSide","startI","endI","b","copy","Uint16Array","j","enterUnfinishedNodesBefore","scan","childBefore","last","lastChild","prevSibling","overlays","_a","IgnoreOverlays","inner","_parent","e","next","start","ExcludeBuffers","findChild","BufferNode","BufferContext","hasChild","IgnoreMounts","nextChild","rPos","val","nextSignificantParent","before","after","r","getChildren","context","matchNodeContext","cur","is","p","child","externalSibling","parentStart","slice","stack","bufferNode","yieldNode","n","unshift","yieldBuf","yield","enterChild","pop","d","sibling","atLastNode","move","cache","depth","mustLeave","some","ch","nodeSet","maxBufferLength","reused","minRepeatType","takeNode","minPos","inRepeat","end","size","lookAheadAtStart","startPos","maxSize","fork","skip","minStart","nodeSize","localSkipped","nodeStart","findBufferSize","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","lookAheadProp","lastI","makeBalanced","base","pair","concat","bufferStart","topID","nodeSizeCache","balanceType","mkTop","mkTree","total","maxChild","Math","ceil","divide","offset","groupFrom","groupStart","groupSize","nextSize","only","TreeFragment","openStart","openEnd","open","fragments","partial","f","changes","minGap","fI","nextF","cI","off","nextC","nextPos","fromA","cut","fFrom","max","fTo","min","toA","toB","Parser","input","ranges","StringInput","createParse","parse","startParse","done","advance","string","nextTagID","Tag","modified","tag","t","mod","Modifier","sort","a","nextModifierID","instances","mods","exists","find","every","x","configs","array","sets","powerSet","styleTags","byName","tags","part","pieces","rest","m","exec","rule","Rule","ruleNodeProp","other","tagHighlighter","options","style","class","all","cls","sub","tagClass","highlightTree","highlighter","putStyle","builder","HighlightBuilder","highlightRange","highlighters","flush","at","span","inheritedClass","isTop","filter","h","matchContext","getStyleTags","tagCls","highlightTags","startSpan","opaque","innerHighlighters","rangeFrom","rangeTo","define","comment","typeName","propertyName","literal","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","attributeName","className","labelName","namespace","macroName","docString","character","attributeValue","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","moduleKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","strikethrough","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","defineModifier","constant","function","standard","local","special","Recover","Stack","state","reducePos","score","bufferBase","curContext","_","action","parser","dPrec","dynamicPrecedence","pushState","getGoto","minRepeatTerm","storeNode","reduceContext","count","stateFlag","baseStateID","term","isReduce","nextEnd","nextState","maxNode","shiftContext","reduce","shift","updateContext","tracker","reuse","stream","reset","isNode","sim","SimulatedStack","stateSlot","hasAction","nextStates","s","best","v","validAction","target","forceReduce","dialectID","dialect","hash","newCx","StackContext","emitContext","emitLookAhead","strict","cx","goto","StackBufferCursor","maybeNext","CachedToken","extended","mask","nullToken","InputStream","chunk","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","range","readNext","assoc","idx","charCodeAt","resolved","resolveOffset","endOffset","nextChunk","getChunk","setDone","read","TokenGroup","groupMask","accEnd","allows","overrides","acceptToken","low","high","mid","readToken","prototype","contextual","fallback","extend","decodeArray","Type","out","stop","digit","Safety","verbose","process","LOG","stackIDs","cutAt","childAfter","Rec","FragmentCursor","fragment","safeFrom","safeTo","trees","nextFragment","fr","nextStart","TokenCache","tokens","mainToken","actions","tokenizers","actionIndex","main","tokenizer","updateCachedToken","addActions","setLookAhead","eofTerm","clipPos","specialized","specializers","putAction","Parse","recovering","nextStackID","minStackPos","stoppedAt","topTerm","stacks","bufferLength","stopped","stoppedTokens","newStacks","advanceStack","tok","getMainToken","finished","findFinished","stackToTree","console","log","getName","SyntaxError","runRecovery","forceAll","maxRemaining","outer","sameState","splice","stackID","strictCx","cxHash","cached","nodeAt","useNode","defaultReduce","getActions","localStack","apply","pushStackDedup","restarted","tokenEnd","deadEnd","restart","advanceFully","force","forceBase","recoverByInsert","insert","recoverByDelete","close","String","fromCodePoint","Dialect","disabled","LRParser","wrappers","version","nodeNames","repeatNodeCount","topTerms","keys","topRules","nodeProps","setProp","nodeID","propSpec","skippedNodes","propSources","tokenArray","tokenData","specializerSpecs","getSpecializer","states","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","w","loose","table","groupTag","terminal","slot","flag","prev","iPrev","findOffset","info","external","contextTracker","wrap","prec","values","Uint8Array","jsonHighlighting","Number","PropertyName","Null"],"sourceRoot":""}